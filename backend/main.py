"""
ROLE: The Gateway (API)
INTEGRATED: Resilience, Validation, Monitoring, and ML Evaluation
RESPONSIBILITIES:
1. Connects to Redis (Read-only for Dashboard).
2. Serves Statistics (/stats).
3. Serves Recent Transactions (/recent).
4. Serves Fraud Alerts (/alerts).
5. Calculates Model Performance (/performance).
"""
import os
import sys
import json
import logging
import time
import asyncio
import psutil
import redis
import numpy as np
from datetime import datetime
from typing import List, Optional, Dict, Any
from contextlib import asynccontextmanager
from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# Add src to path to import the Sentinel Evaluator 
sys.path.append(os.path.join(os.path.dirname(__file__), "..", "src"))

from schemas import Transaction, StatsResponse 

try:
    from sentinel.evaluation import SentinelEvaluator
except ImportError:
    print("âš ï¸ Warning: Could not import SentinelEvaluator. /performance endpoint may fail.")

# ==============================================================================
# 1. CONFIGURATION
# ==============================================================================
REDIS_HOST = os.getenv('REDIS_HOST', 'redis')
REDIS_PORT = int(os.getenv('REDIS_PORT', '6379'))
REDIS_PASSWORD = os.getenv('REDIS_PASSWORD', None)
ALLOWED_ORIGINS = os.getenv('ALLOWED_ORIGINS', '*').split(',')

# Path to the config file generated by the Worker/Training step
MODEL_CONFIG_PATH = os.getenv('MODEL_CONFIG_PATH', '/app/models/production_config.json')

# ==============================================================================
# 3. STRUCTURED LOGGING
# ==============================================================================
class JsonFormatter(logging.Formatter):
    def format(self, record):
        return json.dumps({
            "timestamp": datetime.fromtimestamp(record.created).isoformat(),
            "level": record.levelname,
            "message": record.getMessage(),
            "service": "sentinel-gateway"
        })

handler = logging.StreamHandler()
handler.setFormatter(JsonFormatter())
logging.basicConfig(level=logging.INFO, handlers=[handler])
logger = logging.getLogger("Gateway")

# ==============================================================================
# 4. REDIS & UTILS
# ==============================================================================
redis_pool = redis.ConnectionPool(
    host=REDIS_HOST, 
    port=REDIS_PORT, 
    password=REDIS_PASSWORD, 
    decode_responses=True,
    socket_timeout=2
)
redis_client = redis.Redis(connection_pool=redis_pool)

def get_production_threshold() -> float:
    """
    Reads the active threshold from the production config file.
    Falls back to 0.5 if file is missing or corrupt.
    """
    try:
        if os.path.exists(MODEL_CONFIG_PATH):
            with open(MODEL_CONFIG_PATH, 'r') as f:
                config = json.load(f)
                return float(config.get('threshold', 0.5))
    except Exception as e:
        logger.warning(f"âš ï¸ Could not load production config: {e}")
    return 0.5

# ==============================================================================
# 5. LIFECYCLE MANAGEMENT
# ==============================================================================
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    app.state.startup_time = time.time()
    retries = 5
    redis_is_ready = False
    logger.info("ðŸš€ Gateway starting...")

    for i in range(retries):
        try:
            if redis_client.ping():
                logger.info("âœ… Gateway connected to Redis")
                redis_is_ready = True
                break
        except Exception:
            logger.warning(f"â³ Redis not ready (Attempt {i+1}/{retries}). Waiting...")
            await asyncio.sleep(2)
    
    if not redis_is_ready:
        logger.critical("âŒ Could not connect to Redis. Gateway starting in degraded mode.")

    yield
    
    # Shutdown
    logger.info("ðŸ›‘ Gateway shutting down...")
    try:
        redis_client.close()
    except Exception as e:
        logger.error(f"âš ï¸ Error closing Redis: {e}")

# ==============================================================================
# 6. APP & ENDPOINTS
# ==============================================================================
app = FastAPI(title="Sentinel Gateway", version="2.2.0", lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_methods=["GET"],
    allow_headers=["*"],
)

@app.get("/", tags=["System"])
def root():
    return {"service": "Sentinel Gateway", "status": "active"}

@app.get("/health", tags=["System"])
def health():
    try:
        redis_client.ping()
        return {"status": "healthy", "uptime": f"{int(time.time() - app.state.startup_time)}s"}
    except:
        raise HTTPException(status_code=503, detail="Redis unreachable")

@app.get("/metrics", tags=["System"])
def get_metrics():
    try:
        redis_status = True if redis_client.ping() else False
    except:
        redis_status = False

    return {
        "memory_usage_mb": round(psutil.Process().memory_info().rss / 1024 / 1024, 2),
        "cpu_usage_percent": psutil.Process().cpu_percent(),
        "redis_connected": redis_status,
        "active_threshold": get_production_threshold()  # Helpful for debugging
    }

@app.get("/stats", response_model=StatsResponse, tags=["Dashboard"])
def get_stats():
    try:
        fraud = int(redis_client.get('stats:fraud_count') or 0)
        legit = int(redis_client.get('stats:legit_count') or 0)
        total = fraud + legit
        
        return {
            "total_processed": total,
            "fraud_detected": fraud,
            "legit_transactions": legit,
            "fraud_rate": round((fraud / total * 100), 2) if total > 0 else 0,
            "queue_depth": redis_client.llen('sentinel_stream'),
            "updated_at": datetime.now().replace(microsecond=0).isoformat()
        }
    except Exception as e:
        logger.error(f"Stats Error: {e}")
        raise HTTPException(status_code=500, detail="Database error")

# @app.get("/recent", response_model=List[Transaction], tags=["Dashboard"])
# def get_recent(limit: int = Query(500, ge=1, le=2000)):
#     try:
#         data = redis_client.lrange('sentinel_stream', 0, limit - 1)
#         return [json.loads(item) for item in data]
#     except Exception as e:
#         logger.error(f"Recent Feed Error: {e}")
#         return []

@app.get("/recent", response_model=List[Transaction], tags=["Dashboard"])
def get_recent(limit: int = Query(500, ge=1, le=2000)):
    try:
        data = redis_client.lrange('sentinel_stream', 0, limit - 1)
        results = []
        for item in data:
            try:
                tx_dict = json.loads(item)
                # Force transaction_id to string if you want consistent UI behavior
                if "transaction_id" in tx_dict:
                    tx_dict["transaction_id"] = str(tx_dict["transaction_id"])
                
                results.append(tx_dict)
            except Exception as e:
                continue
        return results
    except Exception as e:
        logger.error(f"Recent Feed Error: {e}")
        return []

@app.get("/alerts", response_model=List[Transaction], tags=["Dashboard"])
def get_alerts(limit: int = Query(50, ge=1, le=200)):
    try:
        data = redis_client.lrange('sentinel_alerts', 0, limit - 1)
        return [json.loads(item) for item in data]
    except Exception as e:
        logger.error(f"Alerts Feed Error: {e}")
        return []

@app.get("/performance", tags=["Dashboard"])
def get_performance(threshold: Optional[float] = Query(None)):
    """
    Calculates Business KPIs based on recent data.
    If 'threshold' is not provided, it loads the active threshold from production_config.json.
    """
    try:
        # 1. Determine which threshold to use
        active_threshold = threshold
        if active_threshold is None:
            active_threshold = get_production_threshold()

        # 2. Fetch Data
        raw_data = redis_client.lrange('sentinel_stream', 0, 1000)
        if not raw_data:
            return {"status": "no data"}
        
        data = [json.loads(x) for x in raw_data]
        y_true = [d.get('ground_truth', 0) for d in data]
        y_prob = [d.get('score', 0.0) for d in data]
        amounts = [d.get('amount', 0.0) for d in data]
        
        # 3. Evaluate
        if SentinelEvaluator:
            evaluator = SentinelEvaluator(y_true, y_prob, amounts)
            
            report = evaluator.report_business_impact(
                threshold=active_threshold,
                cb_fee=25.0,
                support_cost=10.0
            )
            return {
                "config": {
                    "source": "manual_override" if threshold else "production_config",
                    "threshold_used": active_threshold
                },
                "metrics": {
                    "net_benefit": report['financials']['net_savings'],
                    "fraud_prevented": report['financials']['fraud_stopped_val'],
                    "fraud_missed": report['financials']['fraud_missed_val'],
                    "recall": report['performance']['recall'],
                    "auc": report['performance']['auc'],
                    "fp_ratio": report['performance']['fpr_insult_rate']
                },
                "meta": report['counts']
            }
        else:
            return {"error": "Evaluator not loaded"}

    except Exception as e:
        logger.error(f"Performance Eval Error: {e}")
        raise HTTPException(status_code=500, detail="Evaluation failed")

